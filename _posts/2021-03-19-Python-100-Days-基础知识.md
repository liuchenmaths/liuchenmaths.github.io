---
layout:     post   				    # 使用的布局（不需要改）
title:      《Python 100 Days》基础知识				# 标题 
subtitle:    #副标题
date:       2021-03-19 				# 时间
author:     刘晨 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 笔记
    - Python
---

# 01 初识Python
Python的应用领域  
目前Python在Web服务器应用开发、云基础设施开发、网络数据采集（爬虫）、数据分析、量化交易、机器学习、深度学习、自动化测试、自动化运维等领域都有用武之地。

## Visual Studio Code (VS Code)
Visual Studio Code（通常简称为VS Code）是一个由微软开发能够在Windows、 Linux和macOS等操作系统上运行的代码编辑神器。它支持语法高亮、自动补全、多点编辑、运行调试等一系列便捷功能，而且能够支持多种编程语言。现阶段，强烈建议大家使用VS Code来编写Python代码。

### 在VS Code中使用终端
这是用VSCode编写Python最核心的地方，你不用打开丑丑的CMD，直接在VSCode中就可以运行Python。

点击 【查看—终端 】 或直接快捷键 【Ctrl + ` 】 打开终端，会在下方产生一个CMD控制台：

在这里我们所做的最新修改都可以直接 `python xx.py` 运行。  
不过要注意一下当前的文件夹是否和Python脚本文件处于同一个目录，如果不在同一个目录则要cd进去。

### 一键运行
在VS Code中安装完Python拓展之后,在编辑完代码按F5即可运行（如果你不需要输入参数的话），初次运行可能会让你选环境，选择Python即可。  

## 运行程序
我们也可以在任意位置打开“命令行提示符”或“终端”工具，然后将需要执行的Python代码通过拖拽的方式拖入到“命令行提示符”或“终端”中，这样相当于指定了文件的绝对路径来运行该文件中的Python代码。再次提醒，macOS系统要通过python3命令来运行该程序。

需要提醒大家，上面代码中的print('hello, world')就是一条完整的语句，我们用Python写程序，最好每一行代码中只有一条语句。虽然使用;s分隔符可以将多个语句写在一行代码中，但是最好不要这样做，因为代码会变得非常难看。

## 注释你的代码
Python中有两种形式的注释：  
- 单行注释：以#和空格开头，可以注释掉从#开始后面一整行的内容。
- 多行注释：三个引号开头，三个引号结尾，通常用于添加多行说明性内容。




# 02 语言元素
## Python语言元素之变量
### 变量和类型
变量是数据的载体，简单的说就是一块用来保存数据的内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。  
Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），这里我们需要先了解几种常用的数据类型。  
* 整型（int）：Python中可以处理任意大小的整数，而且支持二进制。
* 浮点型（float）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。
* 字符串型（str）：字符串是以单引号或双引号括起来的任意文本，比如'hello'和"hello"。
* 布尔型（bool）：布尔值只有True、False两种值，要么是True，要么是False。

### 变量命名
* 硬性规则：
  * 变量名由字母、数字和下划线组成，数字不能开头。字母指的是Unicode字符。Unicode称为万国码，囊括了世界上大部分的文字系统，这也就意味着中文、日文、希腊字母等都可以作为变量名中的字符，但是像!、@、#这些特殊字符是不能出现在变量名中的，而且我们强烈建议大家尽可能使用英文字母。
  * 大小写敏感，简单的说就是大写的A和小写的a是两个不同的变量。
  * 变量名不要跟Python语言的关键字（有特殊含义的单词，后面会讲到）和保留字（如函数、模块等的名字）发生重名的冲突。
* 非硬性规则：
  * 变量名通常使用小写英文字母，多个单词用下划线进行连接。
  * 受保护的变量用单个下划线开头
  * 私有的变量用两个下划线开头

### 变量的使用
在Python中可以使用type函数对变量的类型进行检查。  

不同类型的变量可以相互转换，这一点可以通过Python的内置函数来实现。
* `int()`:一个数值或字符串转换成整数，可以指定进制。
* `float()`:将一个字符串转换成浮点数。
* `str()`：将指定的对象转换成字符串形式，可以指定编码。
* `chr()`：将整数转换成该编码对应的字符串（一个字符）。
* `ord()`：将字符串（一个字符）转换成对应的编码（整数）。

```
a = 100
b = 12.345
c = 'hello, world'
d = True
# 整数转成浮点数
print(float(a))    # 100.0
# 浮点型转成字符串 (输出字符串时不会看到引号哟)
print(str(b))      # 12.345
# 字符串转成布尔型 (有内容的字符串都会变成True)
print(bool(c))     # True
# 布尔型转成整数 (True会转成1，False会转成0)
print(int(d))      # 1
# 将整数变成对应的字符 (97刚好对应字符表中的字母a)
print(chr(97))     # a
# 将字符转成整数 (Python中字符和字符串表示法相同)
print(ord('a'))    # 97
```

## Python语言元素之运算符
Python语言支持很多种运算符，我们先用一个表格为大家列出这些运算符，然后选择一些马上就会用到的运算符为大家进行讲解。

![截屏2021-03-19下午1.42.10](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-03-19%20%E4%B8%8B%E5%8D%881.42.10.png)

* `%` 求模运算就是取余数的运算
* `//`整除运算就是除法去掉余数取整
> 说明： 上面这个表格实际上是按照运算符的优先级从上到下列出了各种运算符。所谓优先级就是在一个运算的表达式中，如果出现了多个运算符，应该先执行哪个运算再执行哪个运算的顺序。在实际开发中，如果搞不清楚运算符的优先级，可以使用圆括号来确保运算的执行顺序。

### 赋值运算符
赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。

```
a = 10
b = 3
a += b        # 相当于：a = a + b
print(a)      # a = 13
a *= a + 2    # 相当于：a = a * (a + 2)
print(a)      # 
```

### 比较运算符和逻辑运算符
#### 比较运算符
* 比较运算符有的地方也称为关系运算符，包括`==`、`!=`、`<`、`>`、`<=`、`>=`  
* `=`是赋值运算符，`==`才是相等的运算符
* 比较运算符会产生布尔值，要么是True要么是False。

#### 逻辑运算符
逻辑运算符有三个，分别是and、or和not。and字面意思是“而且”，所以and运算符会连接两个布尔值，如果两个布尔值都是True，那么运算的结果就是True；左右两边的布尔值有一个是False，最终的运算结果就是False。相信大家已经想到了，**如果and左边的布尔值是False，不管右边的布尔值是什么，最终的结果都是False，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在and运算符左边为False的情况下，右边的表达式根本不会执行**。or字面意思是“或者”，所以or运算符也会连接两个布尔值，如果两个布尔值有任意一个是True，那么最终的结果就是True。当然，**or运算符也是有短路功能的**，在它左边的布尔值为True的情况下，右边的表达式根本不会执行。not运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，not后面的布尔值如果是True，运算结果就是False；而not后面的布尔值如果是False，运算结果就是True。

```
flag0 = 1 == 1
flag1 = 3 > 2
flag2 = 2 < 1
flag3 = flag1 and flag2
flag4 = flag1 or flag2
flag5 = not (1 != 2)
print('flag0 =', flag0)    # flag0 = True
print('flag1 =', flag1)    # flag1 = True
print('flag2 =', flag2)    # flag2 = False
print('flag3 =', flag3)    # flag3 = False
print('flag4 =', flag4)    # flag4 = True
print('flag5 =', flag5)    # flag5 = False
```

> 说明：比较运算符的优先级高于赋值运算符，所以flag0 = 1 == 1先做1 == 1产生布尔值True，再将这个值赋值给变量flag0。  
> print函数可以输出多个值，多个值之间可以用,进行分隔，输出的内容之间默认以空格分开

#### 例子1：华氏温度转换为摄氏温度。
> 提示：华氏温度到摄氏温度的转换公式为：C = (F - 32) / 1.8。
```
f = float(input('请输入华氏温度: '))
c = (f - 32) / 1.8
print('%.1f华氏度 = %.1f摄氏度' % (f, c))
```

#### 占位符
在使用print函数输出时，也可以对字符串内容进行格式化处理，上面print函数中的字符串`%.1f`是一个占位符，稍后会由一个float类型的变量值替换掉它。占位符有：  
* `%f`:表示浮点数float，若要自主保留n位小数，可将其表示为`%.nf`
* `%d`：一个int类型的变量值.(实际上也可以表示浮点数float去除整数部分)
* `%s`：字符串。（实际上也可以表示整数int，浮点数float）
  
除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中`{f:.1f}`和`{c:.1f}`可以先看成是`{f}`和`{c}`，表示输出时会用变量f和变量c的值替换掉这两个占位符，后面的`:.1f`表示这是一个浮点数，小数点后保留1位有效数字。

    print(f'{f:.1f}华氏度 = {c:.1f}摄氏度')




# 03 分支结构
## if语句的使用
在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名。  
需要说明的是，不同于C++、Java等编程语言，Python中没有用花括号来构造代码块而是使用了缩进的方式来表示代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。缩进可以使用任意数量的空格，但通常使用4个空格，强烈建议大家不要使用制表键来缩进代码,如果你已经习惯了这么做，可以设置代码编辑工具将1个制表键自动变成4个空格，很多的代码编辑工具都支持这项功能。  

# 04 循环结构
### for loop
如果明确的知道循环执行的次数，我们推荐使用for-in循环，例如计算1到100的和。  

* range(101)：可以用来产生0到100范围的整数，需要注意的是取不到101。
* range(1, 101)：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。
* range(1, 101, 2)：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。
* range(100, 0, -2)：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。

### while loop
如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True则继续循环；表达式的值为False则结束循环。  

#### while True循环
while 是当循环结构，当while 后的条件为真时进行loop，False则终止循环，True是boolean类型的真值，while True即意思是要一直进行loop（死循环）。通常while true 循环中会加入break条件判断用以在循环内部的某个条件达成时终止循环。


### break 和 continue
当while True构造了一个条件恒成立的循环，也就意味着如果不做特殊处理，循环是不会结束的，这也就是常说的“死循环”。为了在用户猜中数字时能够退出循环结构，我们使用了break关键字，它的作用是提前结束循环。需要注意的是，break只能终止它所在的那个循环，这一点在使用嵌套循环结构时需要引起注意，下面的例子我们会讲到什么是嵌套的循环结构。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。  

### 嵌套的循环结构
和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个乘法口诀表（九九表）。  
```
for i in range(1, 10):
    for j in range(1, i + 1):
        print(f'{i}*{j}={i * j}', end='\t')
    print()
```
很显然，在上面的代码中，外层循环用来控制一共会产生9行的输出，而内层循环用来控制每一行会输出多少列。内层循环中的输出就是九九表一行中的所有列，所以在内层循环完成时，有一个print()来实现换行输出的效果。  

## python中\t \r \s \n \f各种转移字符含义
![tyxcj4](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/uPic/tyxcj4.png)

例： 输入两个正整数，计算它们的最大公约数和最小公倍数。  
> 提示：两个数的最大公约数是两个数的公共因子中最大的那个数；两个数的最小公倍数则是能够同时被两个数整除的最小的那个数。  
```
x = int(input('x = '))
y = int(input('y = '))
if x > y:
    x, y = y, x    # Python中可以用这样的方式来交换两个变量的值
for factor in range(x, 0, -1):
    if x % factor == 0 and y % factor == 0:
        print(f'{x}和{y}的最大公约数是{factor}')
        print(f'{x}和{y}的最小公倍数是{x * y // factor}')
        break
```



# 05 构造程序逻辑
### 分支和循环结构的应用
#### 例子1：寻找水仙花数。
说明：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个3位数，该数字每个位上数字的立方之和正好等于它本身，例如：13 + 53 + 33 = 153。

这个题目的关键是将一个三位数拆分为个位、十位、百位，这一点利用Python中的//（整除）和%（求模）运算符其实很容易做到，代码如下所示。
```
for num in range(100, 1000):
    low = num % 10
    mid = num // 10 % 10
    high = num // 100
    if num == low ** 3 + mid ** 3 + high ** 3:
        print(num)
```
上面利用//和%拆分一个数的小技巧在写代码的时候还是很常用的。我们要将一个不知道有多少位的正整数进行反转，例如将12345变成54321，也可以利用这两个运算来实现，代码如下所示。
```
num = int(input('num = '))
reversed_num = 0
while num > 0:
    reversed_num = reversed_num * 10 + num % 10
    num //= 10
print(reversed_num)
```

#### CRAPS赌博游戏
> 说明：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简化后的规则是：玩家第一次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；玩家如果摇出其他点数则玩家继续摇骰子，如果玩家摇出了7点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数玩家继续摇骰子，直到分出胜负。

```
from random import randint

money = 1000
while money > 0:
    print(f'你的总资产为: {money}元')
    go_on = False
    # 下注金额必须大于0小于等于玩家总资产
    while True:
        debt = int(input('请下注: '))
        if 0 < debt <= money:
            break
    # 第一次摇色子
    # 用1到6均匀分布的随机数模拟摇色子得到的点数
    first = randint(1, 6) + randint(1, 6)
    print(f'\n玩家摇出了{first}点')
    if first == 7 or first == 11:
        print('玩家胜!\n')
        money += debt
    elif first == 2 or first == 3 or first == 12:
        print('庄家胜!\n')
        money -= debt
    else:
        go_on = True
    # 第一次摇色子没有分出胜负游戏继续
    while go_on:
        go_on = False
        current = randint(1, 6) + randint(1, 6)
        print(f'玩家摇出了{current}点')
        if current == 7:
            print('庄家胜!\n')
            money -= debt
        elif current == first:
            print('玩家胜!\n')
            money += debt
        else:
            go_on = True
print('你破产了, 游戏结束!')
```

# 06 函数和模块的使用
## 定义函数
数学上的函数通常形如y = f(x)或者z = g(x, y)这样的形式，在y = f(x)中，f是函数的名字，x是函数的自变量，y是函数的因变量；  
而在z = g(x, y)中，g是函数名，x和y是函数的自变量，z是函数的因变量。  
Python中的函数跟这个结构是一致的，每个函数都有自己的名字、自变量和因变量。  
我们通常把Python中函数的自变量称为函数的参数，而因变量称为函数的返回值。  
在Python中可以使用def关键字来定义函数，和变量一样每个函数也应该有一个漂亮的名字，命名规则跟变量的命名规则是一致的  
在函数名后面的圆括号中可以放置传递给函数的参数，就是我们刚才说到的函数的自变量，而函数执行完成后我们会通过return关键字来返回函数的执行结果，就是我们刚才说的函数的因变量。  
一个函数要执行的代码块（要做的事情）也是通过缩进的方式来表示的，跟之前分支和循环结构的代码块是一样的。  
大家不要忘了def那一行的最后面还有一个`:`

## 定义函数：
def是定义函数的关键字、fac是函数名，num是参数（自变量）

```
def fac(num):
    """求阶乘"""
    result = 1
    for n in range(1, num + 1):
        result *= n
    # 返回num的阶乘（因变量）
    return result
m = int(input('m = '))
n = int(input('n = '))
# 当需要计算阶乘的时候不用再写重复的代码而是直接调用函数fac
# 调用函数的语法是在函数名后面跟上圆括号并传入参数
print(fac(m) // fac(n) // fac(m - n))
```

## 函数的参数
### 参数的默认值
如果函数中没有return语句，那么函数默认返回代表空值的None。另外，在定义函数时，函数也可以没有自变量，但是函数名后面的圆括号是必须有的。Python中还允许函数的参数拥有默认值，我们可以把上一课“CRAPS赌博游戏”的摇色子获得点数的功能封装成函数，代码如下所示。

```
from random import randint


# 定义摇色子的函数，n表示色子的个数，默认值为2
def roll_dice(n=2):
    """摇色子返回总的点数"""
    total = 0
    for _ in range(n):
        total += randint(1, 6)
    return total


# 如果没有指定参数，那么n使用默认值2，表示摇两颗色子
print(roll_dice())
# 传入参数3，变量n被赋值为3，表示摇三颗色子获得点数
print(roll_dice(3))
```

我们再来看一个更为简单的例子。

```
def add(a=0, b=0, c=0):
    """三个数相加求和"""
    return a + b + c


# 调用add函数，没有传入参数，那么a、b、c都使用默认值0
print(add())         # 0
# 调用add函数，传入一个参数，那么该参数赋值给变量a, 变量b和c使用默认值0
print(add(1))        # 1
# 调用add函数，传入两个参数，1和2分别赋值给变量a和b，变量c使用默认值0
print(add(1, 2))     # 3
# 调用add函数，传入三个参数，分别赋值给a、b、c三个变量
print(add(1, 2, 3))  # 6
# 传递参数时可以不按照设定的顺序进行传递，但是要用“参数名=参数值”的形式
print(add(c=50, a=100, b=200))    # 350

```
> 注意：带默认值的参数必须放在不带默认值的参数之后，否则将产生SyntaxError错误，错误消息是：non-default argument follows default argument，翻译成中文的意思是“没有默认值的参数放在了带默认值的参数后面”。

### 可变参数
接下来，我们还可以实现一个对任意多个数求和的add函数，因为Python语言中的函数可以通过星号表达式语法来支持可变参数。所谓可变参数指的是在调用函数时，可以向函数传入0个或任意多个参数。将来我们以团队协作的方式开发商业项目时，很有可能要设计函数给其他人使用，但有的时候我们并不知道函数的调用者会向该函数传入多少个参数，这个时候可变参数就可以派上用场。下面的代码演示了用可变参数实现对任意多个数求和的add函数。

```
def add(*args):
    total = 0
    # 可变参数可以放在for循环中取出每个参数的值
    for val in args:
        total += val
    return total
```
## 用模块管理函数
不管用什么样的编程语言来写代码，给变量、函数起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名的函数.  
如果项目是团队协作多人开发的时候，团队中可能有多个程序员都定义了名为foo的函数，这种情况下怎么解决命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块再使用完全限定名的调用方式就可以区分到底要使用的是哪个模块中的foo函数  
在导入模块时，还可以使用as关键字对模块进行别名，这样我们可以使用更为简短的完全限定名。

```
import module1 as m1
import module2 as m2

m1.foo()    # hello, world!
m2.foo()    # goodbye, world!
```
上面的代码我们导入了定义函数的模块，我们也可以使用from...import...语法从模块中直接导入需要使用的函数，  

```
from module1 import foo

foo()    # hello, world!

from module2 import foo

foo()    # goodbye, world!

```
但是，如果我们如果从两个不同的模块中导入了同名的函数，后导入的函数会覆盖掉先前的导入，就像下面的代码中，调用foo会输出hello, world!，因为我们先导入了module2的foo，后导入了module1的foo 。  
```
from module2 import foo
from module1 import foo

foo()    # hello, world!
```
如果想在上面的代码中同时使用来自两个模块中的foo函数也是有办法的，大家可能已经猜到了，还是用as关键字对导入的函数进行别名，代码如下所示。  
```
from module1 import foo as f1
from module2 import foo as f2

f1()    # hello, world!
f2()    # goodbye, world!
```

## 标准库中的模块和函数
Python标准库中提供了大量的模块和函数来简化我们的开发工作，我们之前用过的random模块就为我们提供了生成随机数和进行随机抽样的函数；而time模块则提供了和时间操作相关的函数；上面求阶乘的函数在Python标准库中的math模块中已经有了，实际开发中并不需要我们自己编写，而math模块中还包括了计算正弦、余弦、指数、对数等一系列的数学函数。  
Python标准库中还有一类函数是不需要import就能够直接使用的，我们将其称之为内置函数，这些内置函数都是很有用也是最常用的，下面的表格列出了一部分的内置函数。  

函数 | 说明
---|---
abs | 返回一个数的绝对值，例如：abs(-1.3)会返回1.3。
bin | 把一个整数转换成以'0b'开头的二进制字符串，例如：bin(123)会返回'0b1111011'。
chr | 将Unicode编码转换成对应的字符，例如：chr(8364)会返回'€'。
hex | 将一个整数转换成以'0x'开头的十六进制字符串，例如：hex(123)会返回'0x7b'。
input | 从输入中读取一行，返回读到的字符串。
len | 获取字符串、列表等的长度。
max | 返回多个参数或一个可迭代对象（后面会讲）中的最大值，例如：max(12, 95, 37)会返回95。
min | 返回多个参数或一个可迭代对象（后面会讲）中的最小值，例如：min(12, 95, 37)会返回12。
oct | 把一个整数转换成以'0o'开头的八进制字符串，例如：oct(123)会返回'0o173'。
open | 打开一个文件并返回文件对象（后面会讲）。
ord | 将字符转换成对应的Unicode编码，例如：ord('€')会返回8364。
pow | 求幂运算，例如：pow(2, 3)会返回8；pow(2, 0.5)会返回1.4142135623730951。
print | 打印输出。
range | 构造一个范围序列，例如：range(100)会产生0到99的整数序列。
round | 按照指定的精度对数值进行四舍五入，例如：round(1.23456, 4)会返回1.2346。
sum | 对一个序列中的项从左到右进行求和运算，例如：sum(range(1, 101))会返回5050。
type | 返回对象的类型，例如：type(10)会返回int；而 type('hello')会返回str。

# 07 字符串和常用数据结构
## 字符串的定义
所谓字符串，就是由零个或多个字符组成的有限序列，一般记为：
![JEbyYo](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/uPic/JEbyYo.jpg)
在Python程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。字符串中的字符可以是特殊符号、英文字母、中文字符、日文的平假名或片假名、希腊字母、Emoji字符等。
```
s1 = 'hello, world!'
s2 = "你好，世界！"
print(s1, s2)
# 以三个双引号或单引号开头的字符串可以折行
s3 = '''
hello, 
world!
'''
print(s3, end='')
```
>  提示：print函数中的end=''表示输出后不换行，即将默认的结束符\n（换行符）更换为''（空字符）。

## 转义字符和原始字符串
可以在字符串中使用\（反斜杠）来表示转义，也就是说\后面的字符不再是它原来的意义，例如：\n不是代表反斜杠和字符n，而是表示换行；\t也不是代表反斜杠和字符t，而是表示制表符。所以如果字符串本身又包含了'、"、\这些特殊的字符，必须要通过\进行转义处理。例如要输出一个带单引号或反斜杠的字符串，需要用如下所示的方法。
```
s1 = '\'hello, world!\''
print(s1)
'hello, world!'
s2 = '\\hello, world!\\'
print(s2)
\hello, world!\
```

Python中的字符串可以r或R开头，这种字符串被称为原始字符串，意思是字符串中的每个字符都是它本来的含义，没有所谓的转义字符。例如，在字符串'hello\n'中，\n表示换行；而在r'hello\n'中，\n不再表示换行，就是反斜杠和字符n。大家可以运行下面的代码，看看会输出什么。
```
# 字符串s1中\t是制表符，\n是换行符
s1 = '\time up \now'
print(s1)
	ime up 
ow
# 字符串s2中没有转义字符，每个字符都是原始含义
s2 = r'\time up \now'
print(s2)
\time up \now
```
Python中还允许在\后面还可以跟一个八进制或者十六进制数来表示字符，例如\141和\x61都代表小写字母a，前者是八进制的表示法，后者是十六进制的表示法。另外一种表示字符的方式是在\u后面跟Unicode字符编码，

## 字符串的运算
Python为字符串类型提供了非常丰富的运算符，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串，我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符。
### 拼接和重复
下面的例子演示了使用+和*运算符来实现字符串的拼接和重复操作。
```
s1 = 'hello' + ' ' + 'world'
print(s1)    # hello world
s2 = '!' * 3
print(s2)    # !!!
s1 += s2     # s1 = s1 + s2
print(s1)    # hello world!!!
s1 *= 2      # s1 = s1 * 2
print(s1)    # hello world!!!hello world!!!
```
用*实现字符串的重复是非常有意思的一个运算符，在很多编程语言中，要表示一个有10个a的字符串，你只能写成"aaaaaaaaaa"，但是在Python中，你可以写成'a' * 10。你可能觉得"aaaaaaaaaa"这种写法也没有什么不方便的，那么想一想，如果字符a要重复100次或者1000次又会如何呢？

### 比较运算
对于两个字符串类型的变量，可以直接使用比较运算符比较两个字符串的相等性或大小。需要说明的是，因为字符串在计算机内存中也是以二进制形式存在的，那么字符串的大小比较比的是每个字符对应的编码的大小。例如A的编码是65， 而a的编码是97，所以'A' < 'a'的结果相当于就是65 < 97的结果，很显然是True；而'boy' < 'bad'，因为第一个字符都是'b'比不出大小，所以实际比较的是第二个字符的大小，显然'o' < 'a'的结果是False，所以'boy' < 'bad'的结果也是False。如果不清楚两个字符对应的编码到底是多少，可以使用ord函数来获得，例如ord('A')的值是65，而ord('昊')的值是26122。下面的代码为大家展示了字符串的比较运算。
```
s1 = 'a whole new world'
s2 = 'hello world'
print(s1 == s2, s1 < s2)      # False True
print(s2 == 'hello world')    # True
print(s2 == 'Hello world')    # False
print(s2 != 'Hello world')    # True
s3 = '骆昊'
print(ord('骆'), ord('昊'))               # 39558 26122
s4 = '王大锤'
print(ord('王'), ord('大'), ord('锤'))    # 29579 22823 38180
print(s3 > s4, s3 <= s4)      # True False
```
需要强调一下的是，字符串的比较运算比较的是字符串的内容，Python中还有一个is运算符（身份运算符），如果用is来比较两个字符串，它比较的是两个变量对应的字符串是否在内存中相同的位置（内存地址），简单的说就是两个变量是否对应内存中的同一个字符串。看看下面的代码就比较清楚is运算符的作用了。

```
s1 = 'hello world'
s2 = 'hello world'
s3 = s2
# 比较字符串的内容
print(s1 == s2, s2 == s3)    # True True
# 比较字符串的内存地址
print(s1 is s2, s2 is s3)    # False True
```
### 成员运算
Python中可以用in和not in判断一个字符串中是否存在另外一个字符或字符串，in和not in运算通常称为成员运算，会产生布尔值True或False，代码如下所示。
```
s1 = 'hello, world'
print('wo' in s1)    # True
s2 = 'goodbye'
print(s2 in s1)      # False
```
### 获取字符串长度
获取字符串长度没有直接的运算符，而是使用内置函数len，
### 索引和切片
如果希望从字符串中取出某个字符，我们可以对字符串进行索引运算，运算符是[n]，其中n是一个整数，假设字符串的长度为N，那么n可以是从0到N-1的整数，其中0是字符串中第一个字符的索引，而N-1是字符串中最后一个字符的索引，通常称之为正向索引；在Python中，字符串的索引也可以是从-1到-N的整数，其中-1是最后一个字符的索引，而-N则是第一个字符的索引，通常称之为负向索引。注意，因为字符串是不可变类型，所以不能通过索引运算修改字符串中的字符。

需要提醒大家注意的是，在进行索引操作时，如果索引越界（正向索引不在0到N-1范围，负向索引不在-1到-N范围），会引发IndexError异常，错误提示信息为：string index out of range（字符串索引超出范围）。

果要从字符串中取出多个字符，我们可以对字符串进行切片，运算符是[i:j:k]，其中i是开始索引，索引对应的字符可以取到；j是结束索引，索引对应的字符不能取到；k是步长，默认值为1，表示从前向后获取相邻字符的连续切片，所以:k部分可以省略。假设字符串的长度为N，当k > 0时表示正向切片（从前向后获取字符），如果没有给出i和j的值，则i的默认值是0，j的默认值是N；当k < 0时表示负向切片（从后向前获取字符），如果没有给出i和j的值，则i的默认值是-1，j的默认值是-N - 1。

### 循环遍历
略

## 字符串的方法
在Python中，我们可以通过字符串类型自带的方法对字符串进行操作和处理，对于一个字符串类型的变量，我们可以用变量名.方法名()的方式来调用它的方法。所谓方法其实就是跟某个类型的变量绑定的函数，后面我们讲面向对象编程的时候还会对这一概念详加说明。
### 大小写相关操作
下面的代码演示了和字符串大小写变换相关的方法。
```
s1 = 'hello, world!'

# 使用capitalize方法获得字符串首字母大写后的字符串
print(s1.capitalize())   # Hello, world!
# 使用title方法获得字符串每个单词首字母大写后的字符串
print(s1.title())        # Hello, World!
# 使用upper方法获得字符串大写后的字符串
print(s1.upper())        # HELLO, WORLD!

s2 = 'GOODBYE'
# 使用lower方法获得字符串小写后的字符串
print(s2.lower())        # goodbye
```

### 查找操作
如果想在一个字符串中从前向后查找有没有另外一个字符串，可以使用字符串的find或index方法。
```
s = 'hello, world!'

# find方法从字符串中查找另一个字符串所在的位置
# 找到了返回字符串中另一个字符串首字符的索引
print(s.find('or'))        # 8
# 找不到返回-1
print(s.find('shit'))      # -1
# index方法与find方法类似
# 找到了返回字符串中另一个字符串首字符的索引
print(s.index('or'))       # 8
# 找不到引发异常
print(s.index('shit'))     # ValueError: substring not found
```
在使用find和index方法时还可以通过方法的参数来指定查找的范围，也就是查找不必从索引为0的位置开始。find和index方法还有逆向查找（从后向前查找）的版本，分别是rfind和rindex，代码如下所示。
```
s = 'hello good world!'

# 从前向后查找字符o出现的位置(相当于第一次出现)
print(s.find('o'))       # 4
# 从索引为5的位置开始查找字符o出现的位置
print(s.find('o', 5))    # 7
# 从后向前查找字符o出现的位置(相当于最后一次出现)
print(s.rfind('o'))      # 12
```

### 性质判断
可以通过字符串的startswith、endswith来判断字符串是否以某个字符串开头和结尾；还可以用is开头的方法判断字符串的特征，这些方法都返回布尔值，代码如下所示。
```
s1 = 'hello, world!'

# startwith方法检查字符串是否以指定的字符串开头返回布尔值
print(s1.startswith('He'))    # False
print(s1.startswith('hel'))   # True
# endswith方法检查字符串是否以指定的字符串结尾返回布尔值
print(s1.endswith('!'))       # True

s2 = 'abc123456'

# isdigit方法检查字符串是否由数字构成返回布尔值
print(s2.isdigit())    # False
# isalpha方法检查字符串是否以字母构成返回布尔值
print(s2.isalpha())    # False
# isalnum方法检查字符串是否以数字和字母构成返回布尔值
print(s2.isalnum())    # True
```

### 格式化字符串
在Python中，字符串类型可以通过center、ljust、rjust方法做居中、左对齐和右对齐的处理。
```
s = 'hello, world'

# center方法以宽度20将字符串居中并在两侧填充*
print(s.center(20, '*'))  # ****hello, world****
# rjust方法以宽度20将字符串右对齐并在左侧填充空格
print(s.rjust(20))        #         hello, world
# ljust方法以宽度20将字符串左对齐并在右侧填充~
print(s.ljust(20, '~'))   # hello, world~~~~~~~~
```
我们之前讲过，在用print函数输出字符串时，可以用下面的方式对字符串进行格式化。
```
a = 321
b = 123
print('%d * %d = %d' % (a, b, a * b))
```
当然，我们也可以用字符串的方法来完成字符串的格式，代码如下所示。
```
a = 321
b = 123
print('{0} * {1} = {2}'.format(a, b, a * b))
```
从Python 3.6开始，格式化字符串还有更为简洁的书写方式，就是在字符串前加上f来格式化字符串，在这种以f打头的字符串中，{变量名}是一个占位符，会被变量对应的值将其替换掉，代码如下所示。
```
a = 321
b = 123
print(f'{a} * {b} = {a * b}')
```
如果需要进一步控制格式化语法中变量值的形式，可以参照下面的表格来进行字符串格式化操作。
![eXPquC](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/uPic/eXPquC.png)


### 修剪操作
字符串的strip方法可以帮我们获得将原字符串修剪掉左右两端空格之后的字符串。这个方法非常有实用价值，通常用来将用户输入中因为不小心键入的头尾空格去掉，strip方法还有lstrip和rstrip两个版本，相信从名字大家已经猜出来这两个方法是做什么用的。
```
s = '   jackfrued@126.com  \t\r\n'
# strip方法获得字符串修剪左右两侧空格之后的字符串
print(s.strip())    # jackfrued@126.com
```

## 函数和字符串的应用
### 例子1：设计一个生成指定长度验证码的函数。
```
import random

ALL_CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'


def generate_code(code_len=4):
    """生成指定长度的验证码
    :param code_len: 验证码的长度(默认4个字符)
    :return: 由大小写英文字母和数字构成的随机验证码字符串
    """
    code = ''
    for _ in range(code_len):
        # 产生0到字符串长度减1范围的随机数作为索引
        index = random.randrange(0, len(ALL_CHARS))
        # 利用索引运算从字符串中取出字符并进行拼接
        code += ALL_CHARS[index]
    return code

for _ in range(10):
    print(generate_code()) 
```
上面的函数其实还有一种更为简单的写法，直接利用random模块的随机抽样函数从字符串中取出指定数量的字符，然后利用字符串的join方法将选中的那些字符拼接起来。此外，可以利用Python标准库中的string 模块来获得数字和英文字母的字面常量。
```
import random
import string

ALL_CHARS = string.digits + string.ascii_letters


def generate_code(code_len=4):
    """生成指定长度的验证码
    :param code_len: 验证码的长度(默认4个字符)
    :return: 由大小写英文字母和数字构成的随机验证码字符串
    """
    return ''.join(random.choices(ALL_CHARS, k=code_len))
```
说明：random模块的sample和choices函数都可以实现随机抽样，sample实现无放回抽样，这意味着抽样取出的字符是不重复的；choices实现有放回抽样，这意味着可能会重复选中某些字符。这两个函数的第一个参数代表抽样的总体，而参数k代表抽样的数量。

### 例子2：设计一个函数返回给定文件名的后缀名。
说明：文件名通常是一个字符串，而文件的后缀名指的是文件名中最后一个.后面的部分，也称为文件的扩展名，它是某些操作系统用来标记文件类型的一种机制，例如在Windows系统上，后缀名exe表示这是一个可执行程序，而后缀名txt表示这是一个纯文本文件。需要注意的是，在Linux和macOS系统上，文件名可以以.开头，表示这是一个隐藏文件，像.gitignore这样的文件名，.后面并不是后缀名，这个文件没有后缀名或者说后缀名为''。

```
def get_suffix(filename):
    """获取文件名的后缀名
    :param filename: 文件名
    :return: 文件的后缀名
    """
    # 从字符串中逆向查找.出现的位置
    pos = filename.rfind('.')
    # 通过切片操作从文件名中取出后缀名
    return filename[pos + 1:] if pos > 0 else ''


print(get_suffix('readme.txt'))       # txt
print(get_suffix('readme.txt.md'))    # md
print(get_suffix('.readme'))          #
print(get_suffix('readme.'))          #
print(get_suffix('readme'))           #
```

上面的get_suffix函数还有一个更为便捷的实现方式，就是直接使用os.path模块的splitext函数，这个函数会将文件名拆分成带路径的文件名和扩展名两个部分，然后返回一个二元组（下节课会讲到元组），二元组中的第二个元素就是文件的后缀名（包含.），如果要去掉后缀名中的.，可以做一个字符串的切片操作，代码如下所示。
```
from os.path import splitext


def get_suffix(filename):
    return splitext(filename)[1][1:]
```

### 例子3：在终端中显示跑马灯（滚动）文字。
说明：实现跑马灯文字的原理非常简单，把当前字符串的第一个字符放到要输出的内容的最后面，把从第二个字符开始后面的内容放到要输出的内容的最前面，通过循环重复这个操作，就可以看到滚动起来的文字。两次循环之间的间隔可以通过time模块的sleep函数来实现，而清除屏幕上之前的输出可以使用os模块的system函数调用系统清屏命令来实现。

```
import os
import time

content = '北 京 欢 迎 你 为 你 开 天 辟 地           '
while True:
    # Windows清除屏幕上的输出
    # os.system('cls')  
    # macOS清除屏幕上的输出
    os.system('clear')
    print(content)
    # 休眠0.2秒（200毫秒）
    time.sleep(0.2)
    content = content[1:] + content[0]
```
提示：我们之前建议大家暂时用VS Code来编写Python代码，如果你已经提前开始使用PyCharm了，需要提醒大家，PyCharm的运行窗口无法用上面的方式做清屏处理。建议在“命令行提示符”或“终端”（PyCharm中的“Terminal”相当于就是Windows系统的“命令行提示符”或macOS系统的“终端”）中运行该程序。

注意：  
在写代码尤其是开发商业项目的时候，一定要有意识的将相对独立且重复出现的功能封装成函数，这样不管是自己还是团队的其他成员都可以通过调用函数的方式来使用这些功能。字符串是非常重要的数据类型，字符串的常用运算和方法需要掌握，因为一般的商业项目中，处理字符串比处理数值的操作要更多。


## 常用数据结构之列表
### 定义和使用列表
在Python中，列表是由一系元素按特定顺序构成的数据序列，这样就意味着定义一个列表类型的变量，可以保存多个数据，而且允许有重复的数据。跟上一课我们讲到的字符串类型一样，列表也是一种结构化的、非标量类型，操作一个列表类型的变量，除了可以使用运算符还可以使用它的方法。

在Python中，可以使用[]字面量语法来定义列表，列表中的多个元素用逗号进行分隔，代码如下所示。
```
items1 = [35, 12, 99, 68, 55, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
```
除此以外，还可以通过Python内置的list函数将其他序列变成列表。准确的说，list并不是一个函数，而是创建列表对象的构造器（后面会讲到对象和构造器这两个概念）。
```
items1 = list(range(1, 10))
print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]
items2 = list('hello')
print(items2)    # ['h', 'e', 'l', 'l', 'o']
```
需要说明的是，列表是一种可变数据类型，也就是说列表可以添加元素、删除元素、更新元素，这一点跟我们上一课讲到的字符串有着鲜明的差别。字符串是一种不可变数据类型，也就是说对字符串做拼接、重复、转换大小写、修剪空格等操作的时候会产生新的字符串，原来的字符串并没有发生任何改变。

### 列表的运算符
和字符串类型一样，列表也支持拼接、重复、成员运算、索引和切片以及比较运算，对此我们不再进行赘述，请大家参考下面的代码。
```
items1 = [35, 12, 99, 68, 55, 87]
items2 = [45, 8, 29]

# 列表的拼接
items3 = items1 + items2
print(items3)    # [35, 12, 99, 68, 55, 87, 45, 8, 29]

# 列表的重复
items4 = ['hello'] * 3
print(items4)    # ['hello', 'hello', 'hello']

# 列表的成员运算
print(100 in items3)        # False
print('hello' in items4)    # True

# 获取列表的长度(元素个数)
size = len(items3)
print(size)                 # 9

# 列表的索引
print(items3[0], items3[-size])        # 35 35
items3[-1] = 100
print(items3[size - 1], items3[-1])    # 100 100

# 列表的切片
print(items3[:5])          # [35, 12, 99, 68, 55]
print(items3[4:])          # [55, 87, 45, 8, 100]
print(items3[-5:-7:-1])    # [55, 68]
print(items3[::-2])        # [100, 45, 55, 99, 35]

# 列表的比较运算
items5 = [1, 2, 3, 4]
items6 = list(range(1, 5))
# 两个列表比较相等性比的是对应索引位置上的元素是否相等
print(items5 == items6)    # True
items7 = [3, 2, 1]
# 两个列表比较大小比的是对应索引位置上的元素的大小
print(items5 <= items7)    # True
```
值得一提的是，由于列表是可变类型，所以通过索引操作既可以获取列表中的元素，也可以更新列表中的元素。对列表做索引操作一样要注意索引越界的问题，对于有N个元素的列表，正向索引的范围是0到N-1，负向索引的范围是-1到-N，如果超出这个范围，将引发IndexError异常，错误信息为：list index out of range。


### 列表元素的遍历
如果想逐个取出列表中的元素，可以使用for循环的，有以下两种做法。

```
方法一：
items = ['Python', 'Java', 'Go', 'Kotlin']

for index in range(len(items)):
    print(items[index])

方法二：
items = ['Python', 'Java', 'Go', 'Kotlin']

for item in items:
    print(item)
```



### 列表的方法
#### 添加和删除元素
```
items = ['Python', 'Java', 'Go', 'Kotlin']

# 使用append方法在列表尾部添加元素
items.append('Swift')
print(items)    # ['Python', 'Java', 'Go', 'Kotlin', 'Swift']
# 使用insert方法在列表指定索引位置插入元素
items.insert(2, 'SQL')
print(items)    # ['Python', 'Java', 'SQL', 'Go', 'Kotlin', 'Swift']

# 删除指定的元素
items.remove('Java')
print(items)    # ['Python', 'SQL', 'Go', 'Kotlin', 'Swift']
# 删除指定索引位置的元素
items.pop(0)
items.pop(len(items) - 1)
print(items)    # ['SQL', 'Go', 'Kotlin']

# 清空列表中的元素
items.clear()
print(items)    # []
```

需要提醒大家，在使用remove方法删除元素时，如果要删除的元素并不在列表中，会引发ValueError异常，错误消息是：list.remove(x): x not in list。在使用pop方法删除元素时，如果索引的值超出了范围，会引发IndexError异常，错误消息是：pop index out of range。

从列表中删除元素其实还有一种方式，就是使用Python中的del关键字后面跟要删除的元素，这种做法跟使用pop方法指定索引删除元素没有实质性的区别，但后者会返回删除的元素，前者在性能上略优（del对应字节码指令是DELETE_SUBSCR，而pop对应的字节码指令是CALL_METHOD和POP_TOP）


#### 元素的位置和次数
列表类型的index方法可以查找某个元素在列表中的索引位置；因为列表中允许有重复的元素，所以列表类型提供了count方法来统计一个元素在列表中出现的次数。请看下面的代码。

```
items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']

# 查找元素的索引位置
print(items.index('Python'))       # 0
print(items.index('Python', 2))    # 5
# 注意：虽然列表中有'Java'，但是从索引为3这个位置开始后面是没有'Java'的
print(items.index('Java', 3))      # ValueError: 'Java' is not in list
```

再来看看下面这段代码。

```
items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']

# 查找元素出现的次数
print(items.count('Python'))    # 2
print(items.count('Go'))        # 1
print(items.count('Swfit'))     # 0
```
#### 元素的排序和反转
列表的sort操作可以实现列表元素的排序，而reverse操作可以实现元素的反转，代码如下所示。

```
items = ['Python', 'Java', 'Go', 'Kotlin', 'Python']

# 排序
items.sort()
print(items)    # ['Go', 'Java', 'Kotlin', 'Python', 'Python']
# 反转
items.reverse()
print(items)    # ['Python', 'Python', 'Kotlin', 'Java', 'Go']
```

### 列表的生成式
在Python中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。我们给出两段代码，大家可以做一个对比，看看哪一种方式更加简单优雅。

在Python中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。我们给出两段代码，大家可以做一个对比，看看哪一种方式更加简单优雅。  

1. 通过for循环为空列表添加元素。

```
# 创建一个由1到9的数字构成的列表
items1 = []
for x in range(1, 10):
    items1.append(x)
print(items1)

# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表
items2 = []
for x in 'hello world':
    if x not in ' aeiou':
        items2.append(x)
print(items2)

# 创建一个由个两个字符串中字符的笛卡尔积构成的列表
items3 = []
for x in 'ABC':
    for y in '12':
        items3.append(x + y)
print(items3)
```

2. 通过生成式创建列表。

```
# 创建一个由1到9的数字构成的列表
items1 = [x for x in range(1, 10)]
print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表
items2 = [x for x in 'hello world' if x not in ' aeiou']
print(items2)    # ['h', 'l', 'l', 'w', 'r', 'l', 'd']

# 创建一个由个两个字符串中字符的笛卡尔积构成的列表
items3 = [x + y for x in 'ABC' for y in '12']
print(items3)    # ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']
```

下面这种方式不仅代码简单优雅，而且性能也优于上面使用for循环和append方法向空列表中追加元素的方式。可以简单跟大家交待下为什么生成式拥有更好的性能，那是因为Python解释器的字节码指令中有专门针对生成式的指令（LIST_APPEND指令）；而for循环是通过方法调用（LOAD_METHOD和CALL_METHOD指令）的方式为列表添加元素，方法调用本身就是一个相对耗时的操作。对这一点不理解也没有关系，记住“**强烈建议用生成式语法来创建列表**”这个结论就可以了。

### 嵌套的列表
Python语言没有限定列表中的元素必须是相同的数据类型，也就是说一个列表中的元素可以任意的数据类型，当然也包括列表。如果列表中的元素又是列表，那么我们可以称之为嵌套的列表。嵌套的列表可以用来表示表格或数学上的矩阵，例如：我们想保存5个学生3门课程的成绩，可以定义一个保存5个元素的列表保存5个学生的信息，而每个列表元素又是3个元素构成的列表，分别代表3门课程的成绩。但是，一定要注意下面的代码是有问题的。

```
scores = [[0] * 3] * 5
print(scores)    # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```
看上去我们好像创建了一个5 * 3的嵌套列表，但实际上当我们录入第一个学生的第一门成绩后，你就会发现问题来了，我们看看下面代码的输出。
```
# 嵌套的列表需要多次索引操作才能获取元素
scores[0][0] = 95
print(scores)    # [[95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0]]
```
我们不去过多的解释为什么会出现这样的问题，如果想深入研究这个问题，可以通过[Python Tutor](http://www.pythontutor.com/visualize.html)网站的可视化代码执行功能，看看创建列表时计算机内存中发生了怎样的变化，下面的图就是在这个网站上生成的。建议大家不去纠结这个问题，现阶段只需要记住不能用[[0] * 3] * 5]这种方式来创建嵌套列表就行了。那么创建嵌套列表的正确做法是什么呢，下面的代码会给你答案。

```
scores = [[0] * 3 for _ in range(5)]
scores[0][0] = 95
print(scores)    # [[95, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```
![FzzR9S](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/uPic/FzzR9S.jpg)

## 常用数据额结构之元组
上一节课为大家讲解了Python中的列表，它是一种容器型数据类型，我们可以通过定义列表类型的变量来保存和操作多个元素。当然，Python中容器型的数据类型肯定不止列表一种，接下来我们为大家讲解另一种重要的容器型数据类型，它的名字叫元组（tuple）。
### 定义和使用元组
在Python中，元组也是多个元素按照一定的顺序构成的序列。元组和列表的不同之处在于，**元组是不可变类型**，这就意味着元组类型的变量一旦定义，其中的元素不能再添加或删除，而且元素的值也不能进行修改。定义元组通常使用()字面量语法，也建议大家使用这种方式来创建元组。元组类型支持的运算符跟列表是一样。下面的代码演示了元组的定义和运算。

```
# 定义一个三元组
t1 = (30, 10, 55)
# 定义一个四元组
t2 = ('骆昊', 40, True, '四川成都')

# 查看变量的类型
print(type(t1), type(t2))    # <class 'tuple'> <class 'tuple'>
# 查看元组中元素的数量
print(len(t1), len(t2))      # 3 4

# 通过索引运算获取元组中的元素
print(t1[0], t1[-3])         # 30 30
print(t2[3], t2[-1])         # 四川成都 四川成都

# 循环遍历元组中的元素
for member in t2:
    print(member)

# 成员运算
print(100 in t1)    # False
print(40 in t2)     # True

# 拼接
t3 = t1 + t2
print(t3)           # (30, 10, 55, '骆昊', 40, True, '四川成都')

# 切片
print(t3[::3])      # (30, '骆昊', '四川成都')

# 比较运算
print(t1 == t3)    # False
print(t1 >= t3)    # False
print(t1 < (30, 11, 55))    # True
```
一个元组中如果有两个元素，我们就称之为二元组；一个元组中如果五个元素，我们就称之为五元组。需要提醒大家注意的是，()表示空元组，但是如果元组中只有一个元素，需要加上一个逗号，否则()就不是代表元组的字面量语法，而是改变运算优先级的圆括号，所以('hello', )和(100, )才是一元组，而('hello')和(100)只是字符串和整数。我们可以通过下面的代码来加以验证。

```
# 空元组
a = ()
print(type(a))    # <class 'tuple'>
# 不是元组
b = ('hello')
print(type(b))    # <class 'str'>
c = (100)
print(type(c))    # <class 'int'>
# 一元组
d = ('hello', )
print(type(d))    # <class 'tuple'>
e = (100, )
print(type(e))    # <class 'tuple'>

```
### 元组的应用场景
#### 例子1：打包和解包操作。
当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量，如下面的代码所示。

```
# 打包
a = 1, 10, 100
print(type(a), a)    # <class 'tuple'> (1, 10, 100)
# 解包
i, j, k = a
print(i, j, k)       # 1 10 100
```
在解包时，如果解包出来的元素个数和变量个数不对应，会引发ValueError异常，错误信息为：too many values to unpack（解包的值太多）或not enough values to unpack（解包的值不足）。

有一种解决变量个数少于元素的个数方法，就是使用星号表达式，我们之前讲函数的可变参数时使用过星号表达式。有了星号表达式，我们就可以让一个变量接收多个值，代码如下所示。需要注意的是，用星号表达式修饰的变量会变成一个列表，列表中有0个或多个元素。还有在解包语法中，星号表达式只能出现一次。

```
a = 1, 10, 100, 1000
i, j, *k = a
print(i, j, k)          # 1 10 [100, 1000]
i, *j, k = a
print(i, j, k)          # 1 [10, 100] 1000
*i, j, k = a
print(i, j, k)          # [1, 10] 100 1000
*i, j = a
print(i, j)             # [1, 10, 100] 1000
i, *j = a
print(i, j)             # 1 [10, 100, 1000]
i, j, k, *l = a
print(i, j, k, l)       # 1 10 100 [1000]
i, j, k, l, *m = a
print(i, j, k, l, m)    # 1 10 100 1000 []
```
需要说明一点，解包语法对所有的序列都成立，这就意味着对字符串、列表以及我们之前讲到的range函数返回的范围序列都可以使用解包语法。大家可以尝试运行下面的代码，看看会出现怎样的结果。

```
a, b, *c = range(1, 10)
print(a, b, c)
1 2 [3, 4, 5, 6, 7, 8, 9]
a, b, c = [1, 10, 100]
print(a, b, c)
1 10 100
a, *b, c = 'hello'
print(a, b, c)
h ['e', 'l', 'l'] o
```
现在我们可以反过来思考一下函数的可变参数，可变参数其实就是将多个参数打包成了一个元组，可以通过下面的代码来证明这一点。

```
def add(*args):
    print(type(args), args)
    total = 0
    for val in args:
        total += val
    return total


add(1, 10, 20)        # <class 'tuple'> (1, 10, 20)
add(1, 2, 3, 4, 5)    # <class 'tuple'> (1, 2, 3, 4, 5)
```

#### 例子2：交换两个变量的值。
交换两个变量的值是编程语言中的一个经典案例，在很多编程语言中，交换两个变量的值都需要借助一个中间变量才能做到，如果不用中间变量就需要使用比较晦涩的位运算来实现。在Python中，交换两个变量a和b的值只需要使用如下所示的代码。

`a, b = b, a`

同理，如果要将三个变量a、b、c的值互换，即b赋给a，c赋给b，a赋给c，也可以如法炮制。

`a, b, c = b, c, a`

需要说明的是，上面并没有用到打包和解包语法，Python的字节码指令中有ROT_TWO和ROT_THREE这样的指令可以实现这个操作，效率是非常高的。但是如果有多于三个变量的值要依次互换，这个时候没有直接可用的字节码指令，执行的原理就是我们上面讲解的打包和解包操作。

#### 例子3：让函数返回多个值。
有的时候一个函数执行完成后可能需要返回多个值，这个时候元组类型应该是比较方便的选择。例如，编写一个找出列表中最大值和最小的函数。

```
def find_max_and_min(items):
    """找出列表中最大和最小的元素
    :param items: 列表
    :return: 最大和最小元素构成的二元组
    """
    max_one, min_one = items[0], items[0]
    for item in items:
        if item > max_one:
            max_one = item
        elif item < min_one:
            min_one = item
    return max_one, min_one
```
上面函数的return语句中有两个值，这两个值会组装成一个二元组然后返回。所以调用find_max_and_min函数会得到这个二元组，如果愿意也可以通过解包语法将二元组中的两个值分别赋给两个变量。


### 元组和列表的比较
1. 元组是不可变类型，不可变类型更适合多线程环境，因为它降低了并发访问变量的同步化开销。
2. 元组是不可变类型，通常不可变类型在创建时间和占用空间上面都优于对应的可变类型。我们可以使用sys模块的getsizeof函数来检查保存相同元素的元组和列表各自占用了多少内存空间。我们也可以使用timeit模块的timeit函数来看看创建保存相同元素的元组和列表各自花费的时间，代码如下所示。  

```
import sys
import timeit

a = list(range(100000))
b = tuple(range(100000))
print(sys.getsizeof(a), sys.getsizeof(b))    # 900120 800056

print(timeit.timeit('[1, 2, 3, 4, 5, 6, 7, 8, 9]'))
print(timeit.timeit('(1, 2, 3, 4, 5, 6, 7, 8, 9)'))
```

3. Python中的元组和列表是可以相互转换的，我们可以通过下面的代码来做到。
```
# 将元组转换成列表
info = ('骆昊', 175, True, '四川成都')
print(list(info))       # ['骆昊', 175, True, '四川成都']
# 将列表转换成元组
fruits = ['apple', 'banana', 'orange']
print(tuple(fruits))    # ('apple', 'banana', 'orange')
```

列表和元组都是容器型的数据类型，即一个变量可以保存多个数据。列表是可变数据类型，元组是不可变数据类型，所以列表添加元素、删除元素、清空、排序等方法对于元组来说是不成立的。但是列表和元组都可以进行拼接、成员运算、索引和切片这些操作，就如同之前讲到的字符串类型一样，因为字符串就是字符按一定顺序构成的序列，在这一点上三者并没有什么区别。我们推荐大家使用列表的生成式语法来创建列表，它很好用，也是Python中非常有特色的语法。

## 列表和元组的应用
### 案例1：成绩表和平均分统计。
说明：录入5个学生3门课程的考试成绩，计算每个学生的平均分和每门课的平均分。

下面对列表进行遍历的时候，使用了enumerate函数，这个函数非常有用。我们之前讲过循环遍历列表的两种方法，一种是通过索引循环遍历，一种是直接遍历列表元素。通过enumerate处理后的列表在循环遍历时会取到一个二元组，解包之后第一个值是索引，第二个值是元素，下面是一个简单的对比。

```
items = ['Python', 'Java', 'Go', 'Swift']
for index in range(len(items)):
    print(f'{index}: {items[index]}')
0: Python
1: Java
2: Go
3: Swift

for index, item in enumerate(items):
    print(f'{index}: {item}')
0: Python
1: Java
2: Go
3: Swift

>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))       # 下标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

### 案例2：设计一个函数返回指定日期是这一年的第几天。
略

### 案例3：实现双色球随机选号。
略


### 案例4：幸运的女人。
略


## 常用数据结构之集合
在学习了列表和元组之后，我们再来学习一种容器型的数据类型，它的名字叫集合（set）。说到集合这个词大家一定不会陌生，在数学课本上就有这个概念。通常我们对集合的定义是“把一定范围的、确定的、可以区别的事物当作一个整体来看待”，集合中的各个事物通常称为集合的元素。集合应该满足以下特性：

1. 无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。
2. 互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。
3. 确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现。

Python程序中的集合跟数学上的集合是完全一致的，需要强调的是上面所说的无序性和互异性。无序性说明集合中的元素并不像列中的元素那样一个挨着一个，可以通过索引的方式实现随机访问（随机访问指的是给定一个有效的范围，随机抽取出一个数字，然后通过这个数字获取到对应的元素），所以Python中的集合肯定不能够支持索引运算。另外，集合的互异性决定了集合中不能有重复元素，这一点也是集合区别于列表的关键，说得更直白一些就是，Python中的集合类型具有去重特性。当然，Python中的集合一定是支持in和not in成员运算的，这样就可以确定一个元素是否属于集合，也就是上面所说的集合的确定性。集合的成员运算在性能上要优于列表的成员运算，这是集合的底层存储特性决定的，此处我们暂时不做讨论，先记下这个结论即可。

### 创建集合
在Python中，创建集合可以使用{}字面量语法，{}中需要至少有一个元素，因为没有元素的{}并不是空集合而是一个空字典，我们下一节课就会大家介绍字典的知识。当然，也可以使用内置函数set来创建一个集合，准确的说set并不是一个函数，而是创建集合对象的构造器，这个知识点我们很快也会讲到，现在不理解跳过它就可以了。要创建空集合可以使用set()；也可以将其他序列转换成集合，例如：set('hello')会得到一个包含了4个字符的集合（重复的l会被去掉）。除了这两种方式，我们还可以使用生成式语法来创建集合，就像我们之前用生成式创建列表那样。要知道集合中有多少个元素，还是使用内置函数len；使用for循环可以实现对集合元素的遍历。

```
# 创建集合的字面量语法(重复元素不会出现在集合中)
set1 = {1, 2, 3, 3, 3, 2}
print(set1)         # {1, 2, 3}
print(len(set1))    # 3

# 创建集合的构造器语法(后面会讲到什么是构造器)
set2 = set('hello')
print(set2)         # {'h', 'l', 'o', 'e'}
# 将列表转换成集合(可以去掉列表中的重复元素)
set3 = set([1, 2, 3, 3, 2, 1])
print(set3)         # {1, 2, 3}

# 创建集合的生成式语法(将列表生成式的[]换成{})
set4 = {num for num in range(1, 20) if num % 3 == 0 or num % 5 == 0}
print(set4)         # {3, 5, 6, 9, 10, 12, 15, 18}

# 集合元素的循环遍历
for elem in set4:
    print(elem)
```

需要提醒大家，集合中的元素必须是hashable类型。所谓hashable类型指的是能够计算出哈希码的数据类型，你可以暂时将哈希码理解为和变量对应的唯一的ID值。通常不可变类型都是hashable类型，如整数、浮点、字符串、元组等，而可变类型都不是hashable类型，因为可变类型无法确定唯一的ID值，所以也就不能放到集合中。集合本身也是可变类型，所以集合不能够作为集合中的元素，这一点请大家一定要注意。

### 集合的运算
Python为集合类型提供了非常丰富的运算符，主要包括：成员运算、交集运算、并集运算、差集运算、比较运算（相等性、子集、超集）等。
#### 成员运算
可以通过成员运算in和not in 检查元素是否在集合中，代码如下所示。

#### 交并差运算
Python中的集合跟数学上的集合一样，可以进行交集、并集、差集等运算，而且可以通过运算符和方法调用两种方式来进行操作，代码如下所示。

```
set1 = {1, 2, 3, 4, 5, 6, 7}
set2 = {2, 4, 6, 8, 10}

# 交集
# 方法一: 使用 & 运算符
print(set1 & set2)                # {2, 4, 6}
# 方法二: 使用intersection方法
print(set1.intersection(set2))    # {2, 4, 6}

# 并集
# 方法一: 使用 | 运算符
print(set1 | set2)         # {1, 2, 3, 4, 5, 6, 7, 8, 10}
# 方法二: 使用union方法
print(set1.union(set2))    # {1, 2, 3, 4, 5, 6, 7, 8, 10}

# 差集
# 方法一: 使用 - 运算符
print(set1 - set2)              # {1, 3, 5, 7}
# 方法二: 使用difference方法
print(set1.difference(set2))    # {1, 3, 5, 7}

# 对称差
# 方法一: 使用 ^ 运算符
print(set1 ^ set2)                        # {1, 3, 5, 7, 8, 10}
# 方法二: 使用symmetric_difference方法
print(set1.symmetric_difference(set2))    # {1, 3, 5, 7, 8, 10}
# 方法三: 对称差相当于两个集合的并集减去交集
print((set1 | set2) - (set1 & set2))      # {1, 3, 5, 7, 8, 10}
```

通过上面的代码可以看出，对两个集合求交集，&运算符和intersection方法的作用是完全相同的，使用运算符的方式更直观而且代码也比较简短。相信大家对交集、并集、差集、对称差这几个概念是比较清楚的，如果没什么印象了可以看看下面的图。

![w0yYw8](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/uPic/w0yYw8.jpg)

集合的交集、并集、差集运算还可以跟赋值运算一起构成复合运算，如下所示。

```
set1 = {1, 3, 5, 7}
set2 = {2, 4, 6}
# 将set1和set2求并集再赋值给set1
# 也可以通过set1.update(set2)来实现
set1 |= set2
print(set1)    # {1, 2, 3, 4, 5, 6, 7}
set3 = {3, 6, 9}
# 将set1和set3求交集再赋值给set1
# 也可以通过set1.intersection_update(set3)来实现
set1 &= set3
print(set1)    # {3, 6}
```

#### 比较运算
两个集合可以用==和!=进行相等性判断，如果两个集合中的元素完全相同，那么==比较的结果就是True，否则就是False。如果集合A的任意一个元素都是集合B的元素，那么集合A称为集合B的子集，即对于∀a∈A，均有a∈B，则A⊆B。A是B的子集，反过来也可以称B是A的超集。如果A是B的子集且A不等于B，那么A就是B的真子集。Python为集合类型提供了判断子集和超集的运算符，其实就是我们非常熟悉的<和>运算符，代码如下所示。

```
set1 = {1, 3, 5}
set2 = {1, 2, 3, 4, 5}
set3 = set2
# <运算符表示真子集，<=运算符表示子集
print(set1 < set2, set1 <= set2)    # True True
print(set2 < set3, set2 <= set3)    # False True
# 通过issubset方法也能进行子集判断
print(set1.issubset(set2))      # True

# 反过来可以用issuperset或>运算符进行超集判断
print(set2.issuperset(set1))    # True
print(set2 > set1)              # True
```

### 集合的方法
Python中的集合是可变类型，我们可以通过集合类型的方法为集合添加或删除元素。

```
# 创建一个空集合
set1 = set()
# 通过add方法添加元素
set1.add(33)
set1.add(55)
set1.update({1, 10, 100, 1000})
print(set1)    # {33, 1, 100, 55, 1000, 10}

# 通过discard方法删除指定元素
set1.discard(100)
set1.discard(99)
print(set1)    # {1, 10, 33, 55, 1000}
# 通过remove方法删除指定元素，建议先做成员运算再删除
# 否则元素如果不在集合中就会引发KeyError异常
if 10 in set1:
    set1.remove(10)
print(set1)    # {33, 1, 55, 1000}

# pop方法可以从集合中随机删除一个元素并返回该元素
print(set1.pop())

# clear方法可以清空整个集合
set1.clear()
print(set1)    # set()
```

如果要判断两个集合有没有相同的元素可以使用isdisjoint方法，没有相同元素返回True，否则返回False，代码如下所示。

```
set1 = {'Java', 'Python', 'Go', 'Kotlin'}
set2 = {'Kotlin', 'Swift', 'Java', 'Objective-C', 'Dart'}
set3 = {'HTML', 'CSS', 'JavaScript'}
print(set1.isdisjoint(set2))    # False
print(set1.isdisjoint(set3))    # True
```

### 不可变集合
Python中还有一种不可变类型的集合，名字叫frozenset。set跟frozenset的区别就如同list跟tuple的区别，frozenset由于是不可变类型，能够计算出哈希码，因此它可以作为set中的元素。除了不能添加和删除元素，frozenset在其他方面跟set基本是一样的，下面的代码简单的展示了frozenset的用法。

```
set1 = frozenset({1, 3, 5, 7})
set2 = frozenset(range(1, 6))
print(set1 & set2)    # frozenset({1, 3, 5})
print(set1 | set2)    # frozenset({1, 2, 3, 4, 5, 7})
print(set1 - set2)    # frozenset({7})
print(set1 < set2)    # False

```

Python中的集合底层使用了哈希存储的方式，对于这一点我们暂时不做介绍，在后面的课程有需要的时候再为大家讲解集合的底层原理，现阶段大家只需要知道集合是一种容器，元素必须是hashable类型，与列表不同的地方在于集合中的元素没有序、不能用索引运算、不能重复。


## 常用数据结构之字典
迄今为止，我们已经为大家介绍了Python中的三种容器型数据类型，但是这些数据类型还不足以帮助我们解决所有的问题。例如，我们要保存一个人的信息，包括姓名、年龄、体重、单位地址、家庭住址、本人手机号、紧急联系人手机号等信息，你会发现我们之前学过的列表、元组和集合都不是最理想的选择。

集合肯定是最不合适的，因为集合有去重特性，如果一个人的年龄和体重相同，那么集合中就会少一项信息；同理，如果这个人的家庭住址和单位地址是相同的，那么集合中又会少一项信息。另一方面，虽然列表和元组可以把一个人的所有信息都保存下来，但是当你想要获取这个人的手机号时，你得先知道他的手机号是列表或元组中的第6个还是第7个元素；当你想获取一个人的家庭住址时，你还得知道家庭住址是列表或元组中的第几项。总之，在遇到上述的场景时，列表、元组、字典都不是最合适的选择，我们还需字典（dictionary）类型，这种数据类型最适合把相关联的信息组装到一起，并且可以帮助我们解决程序中为真实事物建模的问题。

Python程序中的字典跟现实生活中的字典很像，它以键值对（键和值的组合）的方式把数据组织到一起，我们可以通过键找到与之对应的值并进行操作。就像《新华字典》中，每个字（键）都有与它对应的解释（值）一样，每个字和它的解释合在一起就是字典中的一个条目，而字典中通常包含了很多个这样的条目。

### 创建和使用字典
在Python中创建字典可以使用{}字面量语法，这一点跟上一节课讲的集合是一样的。但是字典的{}中的元素是以键值对的形式存在的，每个元素由:分隔的两个值构成，:前面是键，:后面是值。

```
xinhua = {
    '麓': '山脚下', '路': '道，往来通行的地方；方面，地区：南～货，外～货；种类：他俩是一～人',
    '蕗': '甘草的别名', '潞': '潞水，水名，即今山西省的浊漳河；潞江，水名，即云南省的怒江'
}
print(xinhua)
person = {
    'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号', 
    'home': '中同仁路8号', 'tel': '13122334455', 'econtact': '13800998877'
}
print(person)
```

当然，如果愿意，我们也可以使用内置函数dict或者是字典的生成式语法来创建字典，代码如下所示。

```
# dict函数(构造器)中的每一组参数就是字典中的一组键值对
person = dict(name='王大锤', age=55, weight=60, home='中同仁路8号')
print(person)    # {'name': '王大锤', 'age': 55, 'weight': 60, 'home': '中同仁路8号'}

# 可以通过Python内置函数zip压缩两个序列并创建字典
items1 = dict(zip('ABCDE', '12345'))
print(items1)    # {'A': '1', 'B': '2', 'C': '3', 'D': '4', 'E': '5'}
items2 = dict(zip('ABCDE', range(1, 10)))
print(items2)    # {'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5}

# 用字典生成式语法创建字典
items3 = {x: x ** 3 for x in range(1, 6)}
print(items3)     # {1: 1, 2: 8, 3: 27, 4: 64, 5: 125}
```

想知道字典中一共有多少组键值对，仍然是使用len函数；如果想对字典进行遍历，可以用for循环，但是需要注意，for循环只是对字典的键进行了遍历，不过没关系，在讲完字典的运算后，我们可以通过字典的键获取到和这个键对应的值。

### 字典的运算
对于字典类型来说，成员运算和索引运算肯定是最为重要的，前者可以判定指定的键在不在字典中，后者可以通过键获取对应的值或者向字典中加入新的键值对。值得注意的是，字典的索引不同于列表的索引，列表中的元素因为有属于自己有序号，所以列表的索引是一个整数；字典中因为保存的是键值对，所以字典的索引是键值对中的键，通过索引操作可以修改原来的值或者向字典中存入新的键值对。需要特别提醒大家注意的是，字典中的键必须是不可变类型，例如整数（int）、浮点数（float）、字符串（str）、元组（tuple）等类型的值；显然，列表（list）和集合（set）是不能作为字典中的键的，当然字典类型本身也不能再作为字典中的键，因为字典也是可变类型，但是字典可以作为字典中的值。关于可变类型不能作为字典中的键的原因，我们在后面的课程中再为大家详细说明。这里，我们先看看下面的代码，了解一下字典的成员运算和索引运算。

```
person = {'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号'}
# 检查name和tel两个键在不在person字典中
print('name' in person, 'tel' in person)    # True False
# 通过age修将person字典中对应的值修改为25
if 'age' in person:
    person['age'] = 25
# 通过索引操作向person字典中存入新的键值对
person['tel'] = '13122334455'
person['signature'] = '你的男朋友是一个盖世垃圾，他会踏着五彩祥云去赢取你的闺蜜'
print('name' in person, 'tel' in person)    # True True
# 检查person字典中键值对的数量
print(len(person))    # 6
# 对字典的键进行循环并通索引运算获取键对应的值
for key in person:
    print(f'{key}: {person[key]}')
```
需要注意，在通过索引运算获取字典中的值时，如指定的键没有在字典中，将会引发KeyError异常。

### 字典的方法
字典类型的方法基本上都跟字典的键值对操作相关，可以通过下面的例子来了解这些方法的使用。例如，我们要用一个字典来保存学生的信息，我们可以使用学生的学号作为字典中的键，通过学号做索引运算就可以得到对应的学生；我们可以把字典中键对应的值也做成一个字典，这样就可以用多组键值对分别存储学生的姓名、性别、年龄、籍贯等信息，代码如下所示。

```
# 字典中的值又是一个字典(嵌套的字典)
students = {
    1001: {'name': '狄仁杰', 'sex': True, 'age': 22, 'place': '山西大同'},
    1002: {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'},
    1003: {'name': '武则天', 'sex': False, 'age': 20, 'place': '四川广元'}
}

# 使用get方法通过键获取对应的值，如果取不到不会引发KeyError异常而是返回None或设定的默认值
print(students.get(1002))    # {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'}
print(students.get(1005))    # None
print(students.get(1005, {'name': '无名氏'}))    # {'name': '无名氏'}

# 获取字典中所有的键
print(students.keys())      # dict_keys([1001, 1002, 1003])
# 获取字典中所有的值
print(students.values())    # dict_values([{...}, {...}, {...}])
# 获取字典中所有的键值对
print(students.items())     # dict_items([(1001, {...}), (1002, {....}), (1003, {...})])
# 对字典中所有的键值对进行循环遍历
for key, value in students.items():
    print(key, '--->', value)

# 使用pop方法通过键删除对应的键值对并返回该值
stu1 = students.pop(1002)
print(stu1)             # {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'}
print(len(students))    # 2
# stu2 = students.pop(1005)    # KeyError: 1005
stu2 = students.pop(1005, {})
print(stu2)             # {}

# 使用popitem方法删除字典中最后一组键值对并返回对应的二元组
# 如果字典中没有元素，调用该方法将引发KeyError异常
key, value = students.popitem()
print(key, value)    # 1003 {'name': '武则天', 'sex': False, 'age': 20, 'place': '四川广元'}

# setdefault可以更新字典中的键对应的值或向字典中存入新的键值对
# setdefault方法的第一个参数是键，第二个参数是键对应的值
# 如果这个键在字典中存在，更新这个键之后会返回原来与这个键对应的值
# 如果这个键在字典中不存在，方法将返回第二个参数的值，默认为None
result = students.setdefault(1005, {'name': '方启鹤', 'sex': True})
print(result)        # {'name': '方启鹤', 'sex': True}
print(students)      # {1001: {...}, 1005: {...}}

# 使用update更新字典元素，相同的键会用新值覆盖掉旧值，不同的键会添加到字典中
others = {
    1005: {'name': '乔峰', 'sex': True, 'age': 32, 'place': '北京大兴'},
    1010: {'name': '王语嫣', 'sex': False, 'age': 19},
    1008: {'name': '钟灵', 'sex': False}
}
students.update(others)
print(students)      # {1001: {...}, 1005: {...}, 1010: {...}, 1008: {...}}

```

跟列表一样，从字典中删除元素也可以使用del关键字，在删除元素的时候如果指定的键索引不到对应的值，一样会引发KeyError异常，具体的做法如下所示。

```
person = {'name': '王大锤', 'age': 25, 'sex': True}
del person['age']
print(person)    # {'name': '王大锤', 'sex': True}
```

### 字典的应用
略

Python程序中的字典跟现实生活中字典非常像，允许我们以键值对的形式保存数据，再通过键索引对应的值。这是一种非常有利于数据检索的数据类型，底层原理我们在后续的课程中再研究。再次提醒大家注意，字典中的键必须是不可变类型，字典中的值可以是任意类型。




# 08 面向对象编程入门

# 09 面向对象进阶

# 10 图形用户界面和游戏开发

# 11 文件和异常

# 12 字符串和正则表达式

# 13 进程和线程

# 14 网络编程入门和网络应用开发

# 15 图像和办公文档处理


致谢：  
该笔记是根据作者[骆昊](https://github.com/jackfrued)所创建的项目[Python-100天从新手到大师](https://github.com/jackfrued/Python-100-Days)整理所得到的。  
在此对作者表示衷心的感谢！！